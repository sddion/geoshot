diff --git a/node_modules/react-native-vision-camera/lib/commonjs/skia/SkiaCameraCanvas.js b/node_modules/react-native-vision-camera/lib/commonjs/skia/SkiaCameraCanvas.js
index 157c3ac..6300097 100644
--- a/node_modules/react-native-vision-camera/lib/commonjs/skia/SkiaCameraCanvas.js
+++ b/node_modules/react-native-vision-camera/lib/commonjs/skia/SkiaCameraCanvas.js
@@ -17,40 +17,26 @@ function SkiaCameraCanvasImpl({
   ...props
 }) {
   const texture = _ReanimatedProxy.ReanimatedProxy.useSharedValue(null);
-  const [width, setWidth] = (0, _react.useState)(0);
-  const [height, setHeight] = (0, _react.useState)(0);
+  const { size, ref } = _SkiaProxy.SkiaProxy.useCanvasSize();
+
   _ReanimatedProxy.ReanimatedProxy.useFrameCallback(() => {
     'worklet';
-
-    // 1. atomically pop() the latest rendered frame/texture from our queue
     const latestTexture = offscreenTextures.value.pop();
-    if (latestTexture == null) {
-      // we don't have a new Frame from the Camera yet, skip this render.
-      return;
-    }
-
-    // 2. dispose the last rendered frame
+    if (latestTexture == null) return;
     texture.value?.dispose();
-
-    // 3. set a new one which will be rendered then
     texture.value = latestTexture;
   });
-  const onLayout = (0, _react.useCallback)(({
-    nativeEvent: {
-      layout
-    }
-  }) => {
-    setWidth(Math.round(layout.width));
-    setHeight(Math.round(layout.height));
-  }, []);
+
   return /*#__PURE__*/_react.default.createElement(_SkiaProxy.SkiaProxy.Canvas, _extends({}, props, {
-    onLayout: onLayout,
+    ref: ref,
+    accessible: false,
+    importantForAccessibility: "no-hide-descendants",
     pointerEvents: "none"
   }), children, /*#__PURE__*/_react.default.createElement(_SkiaProxy.SkiaProxy.Image, {
     x: 0,
     y: 0,
-    width: width,
-    height: height,
+    width: size.width,
+    height: size.height,
     fit: resizeMode,
     image: texture
   }));
diff --git a/node_modules/react-native-vision-camera/lib/module/skia/SkiaCameraCanvas.js b/node_modules/react-native-vision-camera/lib/module/skia/SkiaCameraCanvas.js
index a3b5a4a..7843745 100644
--- a/node_modules/react-native-vision-camera/lib/module/skia/SkiaCameraCanvas.js
+++ b/node_modules/react-native-vision-camera/lib/module/skia/SkiaCameraCanvas.js
@@ -1,5 +1,5 @@
 function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
-import React, { useCallback, useState } from 'react';
+import React from 'react';
 import { ReanimatedProxy } from '../dependencies/ReanimatedProxy';
 import { SkiaProxy } from '../dependencies/SkiaProxy';
 function SkiaCameraCanvasImpl({
@@ -9,40 +9,26 @@ function SkiaCameraCanvasImpl({
   ...props
 }) {
   const texture = ReanimatedProxy.useSharedValue(null);
-  const [width, setWidth] = useState(0);
-  const [height, setHeight] = useState(0);
+  const { size, ref } = SkiaProxy.useCanvasSize();
+
   ReanimatedProxy.useFrameCallback(() => {
     'worklet';
-
-    // 1. atomically pop() the latest rendered frame/texture from our queue
     const latestTexture = offscreenTextures.value.pop();
-    if (latestTexture == null) {
-      // we don't have a new Frame from the Camera yet, skip this render.
-      return;
-    }
-
-    // 2. dispose the last rendered frame
+    if (latestTexture == null) return;
     texture.value?.dispose();
-
-    // 3. set a new one which will be rendered then
     texture.value = latestTexture;
   });
-  const onLayout = useCallback(({
-    nativeEvent: {
-      layout
-    }
-  }) => {
-    setWidth(Math.round(layout.width));
-    setHeight(Math.round(layout.height));
-  }, []);
+
   return /*#__PURE__*/React.createElement(SkiaProxy.Canvas, _extends({}, props, {
-    onLayout: onLayout,
+    ref: ref,
+    accessible: false,
+    importantForAccessibility: "no-hide-descendants",
     pointerEvents: "none"
   }), children, /*#__PURE__*/React.createElement(SkiaProxy.Image, {
     x: 0,
     y: 0,
-    width: width,
-    height: height,
+    width: size.width,
+    height: size.height,
     fit: resizeMode,
     image: texture
   }));
diff --git a/node_modules/react-native-vision-camera/src/skia/SkiaCameraCanvas.tsx b/node_modules/react-native-vision-camera/src/skia/SkiaCameraCanvas.tsx
index 56d4e0e..d534c2e 100644
--- a/node_modules/react-native-vision-camera/src/skia/SkiaCameraCanvas.tsx
+++ b/node_modules/react-native-vision-camera/src/skia/SkiaCameraCanvas.tsx
@@ -1,5 +1,5 @@
-import React, { useCallback, useState } from 'react'
-import type { LayoutChangeEvent, ViewProps } from 'react-native'
+import React from 'react'
+import type { ViewProps } from 'react-native'
 import type { CameraProps } from '../types/CameraProps'
 import type { ISharedValue } from 'react-native-worklets-core'
 import type { SkImage } from '@shopify/react-native-skia'
@@ -7,49 +7,28 @@ import { ReanimatedProxy } from '../dependencies/ReanimatedProxy'
 import { SkiaProxy } from '../dependencies/SkiaProxy'
 
 interface SkiaCameraCanvasProps extends ViewProps {
-  /**
-   * The offscreen textures queue that have been rendered by the Skia Frame Processor.
-   *
-   * This view will always pop the latest Texture from this queue and render it.
-   */
   offscreenTextures: ISharedValue<SkImage[]>
-  /**
-   * The resize mode to use for displaying the feed
-   */
   resizeMode: CameraProps['resizeMode']
 }
 
 function SkiaCameraCanvasImpl({ offscreenTextures, resizeMode = 'cover', children, ...props }: SkiaCameraCanvasProps): React.ReactElement {
   const texture = ReanimatedProxy.useSharedValue<SkImage | null>(null)
-  const [width, setWidth] = useState(0)
-  const [height, setHeight] = useState(0)
+  const { size, ref } = SkiaProxy.useCanvasSize()
 
   ReanimatedProxy.useFrameCallback(() => {
     'worklet'
-
-    // 1. atomically pop() the latest rendered frame/texture from our queue
     const latestTexture = offscreenTextures.value.pop()
-    if (latestTexture == null) {
-      // we don't have a new Frame from the Camera yet, skip this render.
-      return
-    }
-
-    // 2. dispose the last rendered frame
+    if (latestTexture == null) return
     texture.value?.dispose()
-
-    // 3. set a new one which will be rendered then
     texture.value = latestTexture
   })
 
-  const onLayout = useCallback(({ nativeEvent: { layout } }: LayoutChangeEvent) => {
-    setWidth(Math.round(layout.width))
-    setHeight(Math.round(layout.height))
-  }, [])
-
   return (
-    <SkiaProxy.Canvas {...props} onLayout={onLayout} pointerEvents="none">
+    <SkiaProxy.Canvas {...props} ref={ref} accessible={false} importantForAccessibility="no-hide-descendants" pointerEvents="none">
       {children}
-      <SkiaProxy.Image x={0} y={0} width={width} height={height} fit={resizeMode} image={texture} />
+      <SkiaProxy.Image x={0} y={0} width={size.width} height={size.height} fit={resizeMode} image={texture} />
     </SkiaProxy.Canvas>
   )
 }
